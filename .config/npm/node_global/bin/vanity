#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cluster_1 = __importDefault(require("cluster"));
const os_1 = __importDefault(require("os"));
const process_1 = __importDefault(require("process"));
const chalk_1 = __importDefault(require("chalk"));
const commander_1 = require("commander");
const ora_1 = __importDefault(require("ora"));
const qrcode_terminal_1 = __importDefault(require("qrcode-terminal"));
const vanity_address_1 = require("./vanity-address");
// Default to half your CPUs
const defaultWorkers = Math.max(1, os_1.default.cpus().length / 2);
const exit = (err) => {
    for (const id in cluster_1.default.workers) {
        const worker = cluster_1.default.workers[id];
        worker?.process.kill();
    }
    if (err) {
        console.error(err);
        process_1.default.exit(1);
    }
    process_1.default.exit(0);
};
/**
 * Parse arguments
 */
const program = new commander_1.Command();
const { prefix, suffix, caseSensitive, qrCode, workers } = program
    .name("vanity-solana")
    .option("-p, --prefix <prefix>", "prefix of the address", "")
    .option("-s, --suffix <suffix>", "suffix of the address", "")
    .option("-c, --case-sensitive", "case sensitive vanity address", false)
    .option("-q, --qr-code", "show a scannable qr code", false)
    .option("-w, --workers <workers>", "number of worker processes to use", defaultWorkers.toString())
    .parse(process_1.default.argv)
    .opts();
if (cluster_1.default.isMaster || cluster_1.default.isPrimary) {
    let addressesGenerated = 0;
    const spinner = (0, ora_1.default)(`Generating vanity address`).start();
    const numWorkers = Number(workers);
    for (let i = 0; i < numWorkers; i++) {
        const childProcess = cluster_1.default.fork();
        childProcess.on("message", function (message) {
            if (message.keypair) {
                const successMessage = [
                    `Done after ${addressesGenerated.toLocaleString()} addresses`,
                    chalk_1.default.underline.blue("\nPublic Key:"),
                    message.keypair.publicKey,
                    chalk_1.default.underline.blue("Private Key:"),
                    message.keypair.secretKey
                ].join("\n");
                spinner.succeed(successMessage);
                if (qrCode) {
                    qrcode_terminal_1.default.generate(message.keypair.secretKey, { small: true });
                }
                exit();
            }
            else if (message.incrementCounter) {
                addressesGenerated++;
                spinner.text = `Generating vanity address (${addressesGenerated.toLocaleString()})`;
            }
        });
    }
}
else {
    /**
     * Worker Process
     */
    const keypair = (0, vanity_address_1.generateVanityAddress)(prefix, suffix, caseSensitive, () => {
        process_1.default.send && process_1.default.send({ incrementCounter: true });
    });
    if (keypair) {
        process_1.default.send &&
            process_1.default.send({
                keypair: {
                    raw: keypair,
                    publicKey: keypair.publicKey.toBase58(),
                    secretKey: Buffer.from(keypair.secretKey).toString("hex")
                }
            });
    }
}
process_1.default.stdin.resume();
process_1.default.on("exit", exit.bind({}));
process_1.default.on("SIGINT", exit.bind({}));
process_1.default.on("uncaughtException", exit.bind({}));
